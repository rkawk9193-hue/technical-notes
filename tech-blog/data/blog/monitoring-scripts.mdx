---
title: Oracle 성능 진단 전문가의 도구 상자: ASH, SQL Monitor, 및 옵티마이저 튜닝 스크립트
date: '2025-12-24'
tags: ['Oracle', 'SQL', 'Monitoring', 'ASH', 'Performance Tuning', 'DBA', 'MDX']
draft: false
summary: Oracle 데이터베이스의 성능 문제를 진단하고 튜닝하기 위한 핵심 SQL 스크립트 모음입니다. Active Session History (ASH) 분석부터 SQL 모니터링, 옵티마이저 제어 방법까지 심층적으로 다룹니다.
---

## Oracle 성능 진단 전문가의 도구 상자 소개

Oracle 데이터베이스 환경에서 성능 문제가 발생했을 때, 정확하고 신속한 원인 분석은 DBA의 핵심 역량입니다. 본 글은 현업에서 자주 사용되는 고급 진단 도구인 Active Session History (ASH)와 SQL Monitoring을 활용한 핵심 SQL 스크립트 모음을 제공합니다. 또한, 성능 테스트 및 튜닝 시 유용한 세션 환경 설정 및 옵티마이저 제어 기법에 대해서도 다룹니다.

이 스크립트들은 단순히 데이터를 조회하는 것을 넘어, 현재 및 과거의 데이터베이스 활동, 병목 현상, 그리고 SQL 실행 계획의 효율성을 심층적으로 파악하는 데 중점을 둡니다.

---

## 1. 세션 및 시스템 환경 설정 (튜닝 사전 작업)

SQL 튜닝 또는 특정 세션의 동작을 제어할 때, 다양한 파라미터를 임시로 조정할 필요가 있습니다. 다음 스크립트는 옵티마이저의 작동 방식이나 통계 수집 방식을 제어하기 위해 사용되지만, **운영 환경에서 숨겨진 파라미터(Undocumented Parameters)를 사용할 때는 Oracle Support와 충분히 상의해야 합니다.**

### 1.1. 옵티마이저 제어 및 통계 설정

성능 문제를 겪는 특정 세션에 대해 옵티마이저의 기본 동작을 변경하거나, 실행 통계 수집을 활성화할 수 있습니다.

sql
-- 옵티마이저의 비용 기반 변환(CBO)을 비활성화 (특정 상황에서만 사용)
ALTER SESSION SET "_optimizer_cost_based_transformation" = 'off';

-- 행 소스(Row Source) 실행 통계 수집 활성화 (SQL 모니터링 상세 정보를 위해 필수)
ALTER SESSION SET "_rowsource_execution_statistics" = true;

-- SQL Monitor 플랜 라인 최대값 설정 (매우 복잡한 쿼리 분석 시 유용)
ALTER SESSION SET "_sqlmon_max_planlines" = 1000;

-- 옵티마이저의 최대 순열 수 제한 (복잡한 조인 쿼리의 하드 파싱 시간을 줄임)
ALTER SESSION SET "_optimizer_max_permutations" = 100;

-- 통계 레벨을 'ALL'로 설정하여 더 많은 성능 정보를 수집
ALTER SESSION SET STATISTICS_LEVEL = 'ALL';


### 1.2. 응용 프로그램 모듈 설정

특정 세션이 어떤 응용 프로그램이나 모듈에서 실행되었는지 식별할 수 있도록 정보를 설정합니다. 이는 ASH 또는 V$SESSION 뷰에서 추적할 때 매우 유용합니다.

sql
EXEC DBMS_APPLICATION_INFO.SET_MODULE( 'KYH_TEST', 'start' );


---

## 2. SQL 실행 계획 및 모니터링 보고서 조회

장시간 실행되는 SQL 또는 현재 실행 중인 SQL의 성능 저하 원인을 파악하기 위해 실시간 모니터링 리포트와 실제 실행 통계가 포함된 실행 계획을 확인합니다.

### 2.1. 실시간 SQL 모니터 보고서 (SQL Monitor Report)

`DBMS_SQLTUNE.REPORT_SQL_MONITOR` 함수는 SQL의 실시간 실행 상태, I/O, CPU 사용량 등을 상세하게 보여줍니다. SQL 튜닝 시 필수적인 도구입니다.

sql
-- 특정 세션 ID에 대한 SQL 모니터 보고서 조회 (SQL_ID가 NULL인 경우)
SELECT /*+ NO_MERGE */
      DBMS_SQLTUNE.REPORT_SQL_MONITOR(
          SESSION_ID => 8451, 
          REPORT_LEVEL => 'ALL', 
          TYPE => 'TEXT'
      ) TXT
FROM DUAL;

-- 특정 SQL_ID에 대한 SQL 모니터 보고서 조회
SELECT /*+ NO_MERGE */
      DBMS_SQLTUNE.REPORT_SQL_MONITOR(
          SQL_ID => '0hrtfbxf61', 
          REPORT_LEVEL => 'ALL', 
          TYPE => 'TEXT'
      ) TXT
FROM DUAL;


### 2.2. 실제 실행 통계가 포함된 실행 계획 (DBMS_XPLAN)

`DBMS_XPLAN.DISPLAY_CURSOR`를 사용하여 Shared Pool에 있는 커서의 실행 계획을 조회하며, 특히 `allstats last -rows +predicate` 포맷을 사용하면 가장 최근 실행된 쿼리의 실제 통계(A-Rows, A-Time 등)를 확인할 수 있습니다.

sql
SELECT * 
FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(
    NULL, 
    NULL, 
    'allstats last -rows +predicate'
));


---

## 3. Active Session History (ASH) 심층 분석

ASH (`V$ACTIVE_SESSION_HISTORY` 또는 `DBA_HIST_ACTIVE_SESS_HIST`)는 1초마다 활성 세션의 상태를 샘플링하여 기록합니다. 이는 데이터베이스의 병목 현상(Wait Events), 블로킹 세션, 그리고 리소스 사용량을 시계열로 분석하는 데 가장 강력한 도구입니다.

### 3.1. 현재 ASH 데이터 기반 분석 (GV$ACTIVE_SESSION_HISTORY)

다음 스크립트는 특정 SQL ID에 대해 세션이 어떤 이벤트로 대기했고, 해당 이벤트가 어떤 파일 또는 객체와 관련 있는지, 그리고 블로킹 세션이 존재하는지 등을 집계하여 보여줍니다.

sql
SELECT 
    sql_id, 
    TO_CHAR(SAMPLE_TIME, 'yyyymmdd hh24mi') sample_dt, 
    EVENT, 
    P1TEXT, P1, P2TEXT, P3TEXT, P3, 
    BLOCKING_SESSION_STATUS, 
    BLOCKING_SESSION, 
    BLOCKING_SESSION_SERIAL#, 
    BLOCKING_INST_ID,                                     
    
    -- 현재 파일 번호를 기반으로 테이블스페이스 이름 조회
    (SELECT TABLESPACE_NAME FROM dba_data_files WHERE file_id = CURRENT_FILE#) FILE_TABLESPACE_NAME, 
    
    -- 현재 객체 번호를 기반으로 객체 이름 조회
    (SELECT OBJECT_NAME FROM dba_objects WHERE OBJECT_ID = CURRENT_OBJ#) OBJECT_NAME,
    
    SUM(1) cnt -- 1초 단위 샘플링의 집계 (Wait Time)
FROM gv$active_session_history a     
WHERE 1 = 1     
  -- 분석하고자 하는 SQL_ID 지정
  AND sql_id = '5vuh4m2xmps4u' 
  
  -- 특정 대기 이벤트로 필터링 (예: 락 경합)
  -- AND EVENT LIKE '%log file sync%' 
  
GROUP BY 
    sql_id, 
    TO_CHAR(SAMPLE_TIME, 'yyyymmdd hh24mi'), 
    EVENT, 
    P1TEXT, P1, P2TEXT, P3TEXT, P3,       
    CURRENT_FILE#, CURRENT_OBJ#, 
    BLOCKING_SESSION_STATUS, 
    BLOCKING_SESSION, 
    BLOCKING_SESSION_SERIAL#, 
    BLOCKING_INST_ID
ORDER BY 2 DESC;


### 3.2. 과거 ASH 데이터 기반 분석 (DBA_HIST_ACTIVE_SESS_HIST)

AWR 라이선스가 있는 경우, 과거 특정 시점의 성능 문제를 분석하기 위해 `DBA_HIST_ACTIVE_SESS_HIST` 뷰를 사용합니다.

sql
SELECT 
    a.*,                 
    (SELECT TABLESPACE_NAME FROM dba_data_files WHERE file_id = CURRENT_FILE#) FILE_TABLESPACE_NAME, 
    (SELECT OBJECT_NAME FROM dba_objects WHERE OBJECT_ID = CURRENT_OBJ#) OBJECT_NAME                 
FROM dba_hist_active_sess_hist a     
WHERE 1 = 1       
    -- 분석 기간 지정
    AND SAMPLE_TIME >= TO_DATE('2019/06/18 16:38:00', 'yyyy/mm/dd hh24:mi:ss')     
    AND SAMPLE_TIME <= TO_DATE('2019/06/18 17:00:00', 'yyyy/mm/dd hh24:mi:ss')     
    
    -- 블로킹 세션 추적 예시
    AND BLOCKING_SESSION = 1019 
    
    -- 특정 대기 이벤트 (TX 락 경합)
    AND event = 'enq: TX - row lock contention'
ORDER BY SAMPLE_TIME;


### 3.3. 특정 SQL ID의 I/O 바이트 변화 추적

Oracle 11g 이상에서 ASH 뷰는 `DELTA_WRITE_IO_BYTES`와 같은 세부 I/O 정보를 제공합니다. 다음 스크립트는 특정 쿼리가 실행되는 동안 발생하는 I/O 활동을 추적하고 누적 I/O를 계산합니다.

sql
SELECT 
    ROUND(SUM(DELTA_WRITE_IO_BYTES) OVER (
        ORDER BY SAMPLE_TIME
    ) / 1024 / 1024, 2) sum_Mbyts, -- 누적 MBytes
    ROUND(DELTA_WRITE_IO_BYTES / 1024 / 1024, 2) delta_Mbyts, -- 샘플링 시점 I/O MBytes
    a.* 
FROM gv$active_session_history a
WHERE 1 = 1
  AND sql_id = '3gqrjrdgvfdxx' 
  AND SAMPLE_TIME > TO_DATE('20181121 1425', 'yyyymmdd hh24mi')
ORDER BY SAMPLE_TIME DESC;


---

## 4. 고급 진단: Exadata Offload 및 통계 분석

### 4.1. Exadata Cell Offload 효율성 분석

Exadata 환경에서 Cell Offload(셀 오프로드)가 얼마나 효과적으로 작동했는지 확인하는 스크립트입니다. 이는 스마트 스캔(Smart Scan) 성능을 측정하는 데 사용됩니다.

- `IO_CELL_OFFLOAD_ELIGIBLE_BYTES`: 오프로드 대상이 된 데이터 크기
- `IO_CELL_OFFLOAD_RETURNED_BYTES`: 오프로드 없이 데이터베이스 서버로 반환된 데이터 크기

sql
SELECT 
    sql_id, 
    io_cell_offload_eligible_bytes qualifying, -- 오프로드 적격 바이트
    io_cell_offload_returned_bytes actual,     -- 실제로 반환된 바이트
    ROUND(
        ((io_cell_offload_eligible_bytes - io_cell_offload_returned_bytes) / 
         NULLIF(io_cell_offload_eligible_bytes, 0)
        ) * 100, 2) io_saved_pct, -- Offload를 통해 절약된 비율
    sql_text, 
    sql_fulltext 
FROM gv$sql 
WHERE sql_id = 'c4hcbwkfyc770';


### 4.2. 테이블 통계 수집

성능 저하의 흔한 원인 중 하나는 오래되거나 부정확한 테이블 및 인덱스 통계입니다. `DBMS_STATS` 패키지를 사용하여 통계를 수집합니다.

sql
EXEC dbms_stats.gather_table_stats( 
    ownname => 'AMISDBA', 
    tabname => 'NRNCCUNVT', 
    degree => 4, -- 병렬 처리 레벨
    cascade => TRUE -- 관련 인덱스 통계도 수집
);


### 4.3. 인덱스 구조 유효성 검사

인덱스가 논리적으로 손상되었는지 확인하고 인덱스 통계 정보를 조회합니다.

sql
-- 인덱스 구조 유효성 검사 (index_stats 뷰에 결과 저장)
ANALYZE INDEX owner.index_name VALIDATE STRUCTURE;

-- 인덱스 통계 조회 (B*Tree 구조 효율, 사용률 등)
SELECT 
    blocks, 
    lf_blocks, 
    btree_space, 
    pct_used, 
    del_if_rows, 
    a.* 
FROM index_stats;


---

## 결론 및 베스트 프랙티스

Oracle 성능 진단은 정교한 도구와 깊은 이해를 요구합니다. 위에 제시된 스크립트들은 현장에서 가장 흔하고 심각한 성능 문제(대기 이벤트, 블로킹, 비효율적인 실행 계획)를 해결하는 데 필요한 기초 자료를 제공합니다.

### 성능 튜닝 베스트 프랙티스

1.  **샘플링 기반 접근 (ASH 활용):** CPU를 많이 쓰는 세션뿐만 아니라 특정 I/O 또는 락(Lock) 이벤트로 대기하는 세션을 식별하는 데 ASH 쿼리를 적극 활용해야 합니다.
2.  **전체 환경 이해:** 세션 파라미터를 변경할 때는 변경의 의도(예: CBO 끄기)와 그에 따른 잠재적 위험성을 항상 인지해야 합니다.
3.  **실행 계획 비교:** 단순히 실행 계획만 보는 것이 아니라, `allstats last`를 통해 **실제 실행 통계**를 반드시 확인하여 예상 행 수와 실제 행 수(Cardinality)의 차이를 파악해야 합니다.
4.  **병렬 처리 신중 사용:** `FORCE PARALLEL`과 같은 옵션은 리소스 경합을 유발할 수 있으므로, 테스트 환경에서 충분히 검증한 후 사용해야 합니다.
5.  **숨겨진 파라미터 경고:** 밑줄(`_`)로 시작하는 숨겨진 파라미터는 릴리스 업그레이드 시 예기치 않게 변경되거나 제거될 수 있으므로, 반드시 필요한 경우가 아니라면 사용을 지양해야 합니다.
---